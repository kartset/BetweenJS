BetweenJS v.0.9.8

Tweening Engine for JS


Requires :
!!! No Dependencies !!!

+ includes Type & Pkg, OOP Class system from StrawNode
+ AMD compatible


Tested Browsers : IE7+  /  FF 15 + / CHR 15 + / SAF 4+

API :
BetweenJS API
BetweenJS.to>(target, to, time, easing)
Creates a regular tween.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'width':100, 'height':100 }) ;

tw = BetweenJS.to(
  box[0], 
  {
    'width':200,
    'height':200
  },
  .35,
  Expo.easeIn
).play() ;
BetweenJS.from>(target, from, time, easing)
Creates a regular tween along the 'from' properties object.
>>> Run

'From' means that the object will tween to its own current properties, from the ones passed in as argument.
if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'width':100, 'height':100 }) ;

tw = BetweenJS.from(
  box[0], 
  {
    'width':400,
    'height':400
  },
  .35,
  Expo.easeIn
).play() ;
BetweenJS.tween>(target, to, from, time, easing)
Creates a regular tween along the 'to' and the 'from' properties object.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box') ;

tw = BetweenJS.tween(
  box[0], 
  {
    'width':400,
    'height':400
  },
  {
    'width':100,
    'height':100
  },
  .55,
  Elastic.easeOut
).play() ;

* depending on the case, we will want to control those destination, and source properties for all the 'play' calls, or just let the tween's target update just from where it arrived.
BetweenJS.apply>(target, to, from, time, applyTime, easing)
Creates a Tween and apply it with an immediate effect, accurate for setting desired values in the time-range of the tween.
Time & ApplyTime defaults to 1.
>>> Run

For an instant setting
BetweenJS.apply( $('#box')[0],
  { 'width':200, 'height':50 }) ;
betweenJS.bezierTo>(target, to, controlPoint, time, easing)
Creates a bezier tween, along cuepoints defined in 'controlpoint' object. 
Accepts single cuepoints object or array of cuepoints object.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'right':0, 'top':0 }) ;

tw = BetweenJS.bezierTo( box[0],
  { 'right':0, 'top':0 },
  { 
    'right':[500, 250],
    'top':[-100, 500]
  },
  1.5,
  Bounce.easeOut
).play() ;
>>> Run

If you have only one cuepoint, no need for Array creation
if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'right':0, 'top':0 }) ;

tw = BetweenJS.bezierTo( box[0],
  { 'right':500, 'top':0 },
  { 
    'right':1000
  },
  .55,
  Quint.easeOut
).play() ;

* Keep in mind Bezier rounds a lot towards finding curves, so here 1000 is a little ignored and round around 700.
BetweenJS.bezierFrom>(target, from, controlPoint, time, easing)
Creates a Bezier tween along 'from' properties object, and cuepoints defined in 'controlPoint' object.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'right':0, 'top':0 }) ;

tw = BetweenJS.bezierFrom( box[0],
  { 'right':0, 'top':0 },
  { 
    'right':[500, 250],
    'top':[-100, 500]
  },
  .75,
  Quint.easeOut
).play() ;
>>> Run

Then you can comment the first jquery style-set, which makes the tween update from where it lands, and click rapidly to see the difference with original.
if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box') ;

tw = BetweenJS.bezierFrom( box[0],
  { 'right':0, 'top':0 },
  { 
    'right':[500, 250],
    'top':[-100, 500]
  },
  .75,
  Quint.easeOut
).play() ;
BetweenJS.bezier>(target, to, from, controlPoint, time, easing)
Creates a Bezier tween, along 'to' and 'from' properties object, and cuepoints defined in 'controlPoint object.'
>>> Run

Once again, controlling controlling both destination and source properties, robustness in transition exactitude.
if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box') ;

tw = BetweenJS.bezier( box[0],
  { 'right':300, 'top':300 },
  { 'right':0, 'top':0 },
  { 
    'right':[150, 150, 300, 300],
    'top':[0, 150, 150, 300]
  },
  1.25,
  Cubic.easeOut
).play() ;
BetweenJS.physicalTo>(target, to, easing)
Creates a Physical tween.
A time-unrelated tween object, tweening along three possible physical calculations :
Physical.uniform,
Physical.accelerate
and Physical.exponential.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'width':100, 'height':100 });

tw = BetweenJS.physicalTo( box[0],
  { 'width':400, 'height':400 },
  Physical.exponential()
).play() ;

* Custom easings could be defined, reproducing the scheme as described in source code.
BetweenJS.physicalFrom>(target, from, easing)
Creates a Physical tween along the 'from' properties object.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'width':100, 'height':100 });

tw = BetweenJS.physicalFrom( box[0],
  { 'width':400, 'height':400 },
  Physical.exponential()
).play() ;
BetweenJS.physical>(target, to, from, easing)
Creates a physical tween along 'to' and 'from' properties objects.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'width':100, 'height':100 }) ;

tw = BetweenJS.physical( box[0],
  { 'width':300, 'height':300 },
  { 'width':600, 'height':600 },
  Physical.accelerate()
) ;
tw.play() ;
BetweenJS.physicalApply>(target, to, from, applytime, easing)
Creates a physical tween and apply changes with an immediate effect, according to parameter 'applyTime'.
>>> Run

BetweenJS.physicalApply( $('#box')[0],
  { 'width':400, 'height':50 },
  undefined,
  .2,
  Physical.uniform()
) ;
BetweenJS.parallel>(tween [, ...])
Creates a new tween composed with the specified tween objects.
Making them occur simultaneously.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'right': 0, 'top': 0 }) ;

var t1 = BetweenJS.to(
  box[0], 
  { 'top':150 },
  .5,
  Bounce.easeOut
) ;
var t2 = BetweenJS.to(
  box[0], 
  { 'right':300 },
  .5,
  Quad.easeOut
) ;

tw = BetweenJS.parallel(
  t1,
  t2
).play() ;
BetweenJS.parallelTweens>(tweens)
Creates a new tween composed with the specified tween objects.
('tweens' being an array of tweens).
Those internal tweens should occur simultaneously.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'right': 0, 'top': 0 }),
  letters = box.find('.node'), size = letters.size() ;

var tweens = letters.map(function(i, el){
  var letter = $(el) ;
  return BetweenJS.serial(BetweenJS.tween(letter[0],
      {'top':-80},
      {'top':0},
      .5 - ((size - i - 1) * .05),
      Expo.easeIn
    ),
    BetweenJS.tween(letter[0],
      {'top':0},
      {'top':80},
      .5 - (i * .05),
      Expo.easeOut
    )
  )
}) ;

tw = BetweenJS.parallelTweens(tweens).play() ;
BetweenJS.serial>(tweens [, ...])
Creates a new tween composed with the specified tween objects.
 Those internal tweens should occur one after the other.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'right': 0, 'top': 0 }) ;

tw = BetweenJS.serial(
  BetweenJS.to( box[0],
  {'right':100}, .25, Expo.easeOut),
  BetweenJS.to( box[0],
  {'top':100}, .25, Expo.easeOut),
  BetweenJS.to( box[0],
  {'right':0}, .25, Expo.easeOut),
  BetweenJS.to( box[0],
  {'top':0}, .25, Expo.easeOut)
).play() ;
BetweenJS.serialTweens>(tweens)
Creates a new tween composed with the specified tween objects.
('tweens' being an array of tweens).
 Those internal tweens should occur one after the other.
>>> Run

if(!!tw && tw.isPlaying) tw.stop().update(0) ;

var box = $('#box')
  .css({ 'right': 0, 'top': 0 }),
  letters = box.find('.node'), size = letters.size() ;

var tweens = letters.map(function(i, el){
  var letter = $(el) ;
  return BetweenJS.serial(
    BetweenJS.tween(letter[0],
      {'font-size':70},
      {'font-size':24},
      .05,
      Expo.easeOut
    ),
    BetweenJS.tween(letter[0],
      {'font-size':24},
      {'font-size':0},
      .05,
      Expo.easeIn
    )
  )
}) ;

tw = BetweenJS.serialTweens(tweens).play() ;
BetweenJS.reverse>(tween, reversePosition)
Creates a Reversed tween, based upon the specified tween.
If 'reversePosition' is set to true, the tween effect from  the original tween's actual position.
>>> Run

if(!!!tw ) tw = window.defaultTween() ;

else {
  
  if(tw.isPlaying) tw.stop() ;
  
  tw = BetweenJS.reverse(tw).play() ;
  
}

BetweenJS.repeat>(tween, repeatCount)
Creates a repeatable tween, along another tween object.
Specify 'repeatCount' for the number of iterations (default=2).
>>> Run

if(!!!tw ) tw = window.defaultTween() ;

else {
  
  if(tw.isPlaying) tw.stop().update(0) ;
  
  tw = tw instanceof RepeatedTween ?
    tw.play() : BetweenJS.repeat(tw, 3).play() ;
  
}

BetweenJS.delay>(tween, delay, postDelay)
Creates a delayed tween along another tween object. 
will just prepend delay and append postdelay to the time of the original tween.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box') ;

var t1 = BetweenJS.tween(
  box[0], 
  { 'width':400 },
  { 'width':100 },
  .25,
  Expo.easeOut
) ;
var t2 = BetweenJS.reverse(t1) ;

tw = BetweenJS.serial(
  t1,
  BetweenJS.delay(t2, 1.0)
).play() ;
BetweenJS.slice>(tween, begin, end, isPercent)
Creates a sliced tween along another tween.
Will litterally 'cut' the original tween within in the time range specified between 'begin' and 'end' parameters.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'right': 0, 'top': 0 }) ;

var t1 = BetweenJS.tween(
  box[0], 
  { 'right::%':100 },
  { 'right::%':0 },
  .5,
  Expo.easeIn
) ;

tw = BetweenJS.serial(
  t1,
  BetweenJS.slice(
    t1,
    0,
    0
  )
).play() ;
BetweenJS.scale>(tween, scale)
Creates a time-streched tween along another tween object. 
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box')
  .css({ 'right': 0, 'top': 0 }) ;

var t1 = BetweenJS.to(
  box[0], 
  { 'top':150 },
  .45,
  Bounce.easeOut
) ;

tw = BetweenJS.serial(
  t1,
  BetweenJS.delay(BetweenJS.scale(
    BetweenJS.reverse(t1),
    3
  ), 1)
).play() ;
BetweenJS.func>(func, params, useRollback, rollbackFunc, rollbackParams)
Creates an ActionTween, executing a function on tween launch, with ability to specify rollback method and rollback parameters.

ActionTweens are tweens that don't actually interpolate, but wrapped as tween to be chainable with others.

In that example, 'func' will execute an anonymous function, but you can also make your custom ActionTweens if you apply similar methods  as described in source code.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

var box = $('#box') ;

tw = BetweenJS.serial( 
  BetweenJS.to(box[0],
    { 'top': -500},
    .15,
    Cubic.easeOut
  ),
  BetweenJS.func(function(){
    box.css({'top': 600}) ;
  }),
  BetweenJS.to(box[0],
    { 'top':0},
    .25,
    Expo.easeOut
  )
).play() ;

* important : The useRollback param could be handfull, for cases where the AbstractAction is cancelable and must execute code when cancelling.
UseRollback set to true will enable rolling back for the tween.
Then, if rollbackfunc and rollback params are specified, rollback will trigger this rollbackfunc with these rollbackparams, 
if not, rollback will remain enabled, but with triggering func and params, when rolling back.
betweenJS.addChild>(target, parent)
Creates an ActionTween, 
Adding a DomElement to another DomElement.
>>> Run

if(!!tw && tw.isPlaying) tw.stop().update(0) ;

var box = $('#box')
  .css({ 'top':0, 'right':0 }),
  letter = box.find('.letter');

tw = BetweenJS.serial(
  BetweenJS.to(
    box[0], 
    {
      'right':200
    },
    .5,
    Cubic.easeOut
  ),
  BetweenJS.removeFromParent(letter[0]),
  BetweenJS.to(
    box[0], 
    {
      'right':0
    },
    .5,
    Cubic.easeOut
  ),
  BetweenJS.addChild(letter[0], box[0])
).play() ;
betweenJS.removeFromParent>(target)
Creates an ActionTween, 
removing a DomElement  from its parent DomElement.
>>> Run

if(!!tw && tw.isPlaying) tw.stop().update(0) ;

var box = $('#box')
  .css({ 'top':0, 'right':0 }),
  letters = box.find('.node');

tw = BetweenJS.serial(
  BetweenJS.to(
    box[0], 
    {
      'right':200
    },
    .5,
    Cubic.easeOut
  ),
  BetweenJS.serialTweens(
    letters.map(function(j, elm){
      return BetweenJS.removeFromParent(elm) ;
    }).toArray().reverse()
  ),
  BetweenJS.to(
    box[0], 
    {
      'right':0
    },
    .5,
    Cubic.easeOut
  ),
  BetweenJS.serialTweens(
    letters.map(function(j, elm){
      return BetweenJS.addChild(elm, 
        box.children('.letter')[0]) ;
    })
  )
).play() ;
BetweenJS.interval>(timer, func, params)
Creates an ActionTween simulating the window.setInterval method, but using the BetweenJS internal updater instead of a new one in window.

* (enable in-browser javascript console).
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

tw = BetweenJS.interval(220, function(){
  trace(tw === this) ;
  if(this.count >= 10) BetweenJS.clearInterval(tw.uid)
}).bind('complete', function(e){
  
  trace('complete', this) ;
  
}).play() ;

* In this example, 

BetweenJS.clearInterval(tw.uid) ;

can be replaced by tw.stop() , tw.clear(), or even this.stop() and this.clear() since we're in the tween's scope within that event closure.
BetweenJS.timeout>(duration, func, params, useRollback, rollbackfunc, rollbackparams)
Creates an ActionTween simulating the window.settimeout method, but using the BetweenJS internal updater instead of a new one in window.
>>> Run

if(!!tw && tw.isPlaying) tw.stop() ;

tw = BetweenJS.timeout(2, function(){
   alert('timeout complete') ;
}).play() ;

* see BetweenJS.func for more about the rollback
feature parameters.

* to clear the timeout,
similar syntax as for interval :

BetweenJS.clearTimeout(tw.uid) ;

or

tw.clear()  // or even tw.stop() ;
// won't execute timeout closure
Easings>(What makes the difference)
Controlling easings is really the key to best possible render, 
so thanx to Robert Penner,  the BetweenJS engine supports :

Linear (default of course)
Back
Bounce
Circular || Circ
Cubic
Elastic
Exponential || Expo
Quadratic || Quad
Quartic || Quart
Quintic || Quint
Sine

All of these easing support following properties

easeIn
* ex: Expo.easeIn

easeOut
* ex: Expo.easeOut

easeInOut
* ex: Expo.easeInOut

easeOutIn
* ex: Expo.easeOutIn
The TWEEN OBJECT>(The Abstract Tween Model)
Every call to BetweenJS static-like methods returns an object which already extends AbstractTween, (most likely ObjectTween in fact).

Those objects have a manipulating API, ie- tween related controls /settings.

play
* BetweenJS.[somecall].play()

launches the tween, if not already playing.

stop
* BetweenJS.[somecall].stop()

tries to stop the tween if playing.

togglePause
* BetweenJS.[somecall].togglePause()

Pauses/Resumes the tween.

gotoAndPlay
* BetweenJS.[somecall].gotoAndPlay(position)

Launches the tween from given position (in seconds).

gotoAndStop
* BetweenJS.[somecall].gotoAndStop(position)

Same as gotoAndPlay, but stops at position.

update
* BetweenJS.[somecall].update(time)

Requests a single update at given time.

bind / addEL
* BetweenJS.[somecall].bind(type, closure)

Attaches an event listener to the tween

unbind / rmoveEL
* BetweenJS.[somecall].unbind(type, closure)

Removes an event listener to the tween

trigger / dispatch
* BetweenJS.[somecall].dispatch(event || type)

Triggers an event onto the tween

willTrigger / hasEL
* BetweenJS.[somecall].hasEL(event || type)

Checks for the previously attached events on the tween
(the tiny theorical difference between willTrigger and hasEventListener will here be ignored, due to insufficient compliancy within browsers).

Handling without events
* OK, since events could happen to have heavier cost along browsers, direct-methods callbacks system is provided, like the old-school way :

var tw = BetweenJS.to(mybox[0], {'width':100}) ;
tw.onUpdate = function(){
  // scope is the tween object
  if(this.time > .5) this.onUpdate = undefined ;
  // removes callback
}
tw.onUpdateParams = [1, 2, 3] ;
tw.play() ;

These settings exist for all TweenEvent types.
THe Tween Event Object>(and supported events)
The tween event is also an instance of jQuery.Event, so can behave the same.
plus, that event carries refrence to associated tween.

The events that fires on tween are tweenevents instances,
and are ranged within those four event types :

TweenEvent.PLAY || 'play'
* Fired as tween starts.

TweenEvent.STOP || 'stop'
* Fired as tween stops.

TweenEvent.UPDATE || 'update'
* Fired each tween interval.

TweenEvent.COMPLETE || 'complete'
* Fired when the tween has reached the end.
Advanced Settings>(BetweenJS Modes overview)
In those described API examples , target of tweens are DOMElements.
But all other objects still are tweenables.

Between implements units (For DOMElements), colors,  and relative values declarations.

Units
* Units can be set in anonymous object passed as parameter for either destination or source.
You may want to keep the same unit in your tween's start and end, since BetweenJS doesn't handle css-conversion and would probably need an entire other framework for that.
Units handled are :
- 'px' (also default when unspecified)
- '%'
- 'em'
- 'pc'
- 'pt'

To set a tween parameter in other unit than 'px', 
use that syntax in the object :
 {'height::%':100} // for a percent-described value

Same syntax over all other units.

Colors
* Colors are handled maybe a little weirdly for first approach, but does quite a lot for that.
Still, BetweenJS must remain IE7-compmatible, thus there is no hack yet for rgba values.
In this first version of Between, let's forget the alpha this way for now.

Color formats supported :
- hex (& hex shortcut #F60)
- rgb
- hsv

Before, when attacking color transitions, keep in mind that css are complex art, and when evaluating your stylesheet's css declarations, shortcuts (for example:background) will not always set the actual background-color declaration, so you might end up with a confused tween start, as 'background-color' would be cssly-undefined, and tween wouldn't launch correctly in that case.
Remember to css-set all properties you need first, probably safer this way.

Correct case :
[stylesheet] -> .mybox{background-color:#FF6600}
[script] -> BetweenJS.to( $('.mybox')[0], 
    { 'background-color':'#812'}
  )

hex-format declaration :
{'background-color':'#812'}

rgb format declaration :
{'background-color': {r:197, g:100, b:100}}

hsv format declaration :
{'background-color': {h:197, s:100, v:100}}



Relative values
* BetweenJS will handle them as soon as the property name in anonymous object has the '$' prefix.

{'$width':200, '$left':-100} 
// will set width and height relatively each tween launch.

In a close future, heavy re-optimization will enable classname-tweening instead of each time new style declarations. In the principle, it will write css-rules at start, then only change classname of domelements to update style. But this won't be possible for all properties, anyway, the toughest (like alpha) could be prepared (as well as easily compliant) in advance, classname making all the work, and free of each direct-rule-setting.





Original AS3 Project & API
Highly inspired from BetweenAS3 (author:yossy(at)be-interactive.org), 

http://www.libspark.org/wiki/BetweenAS3/en

Update Log v 0.9.8 :
- Includes Type & Pkg

Update Log v 0.9.7 :
- No more event handling in this framework, no need for a half-feature,
since we're trying to optimize calculations, base tweens should not be EventDispatcher
when simple closures are way lighter.
In a close future, a module will be done in StrawExpress, that will overload Tweens 
to make them EventDispatchers if still needed.


Update Log v 0.9.6 :
- Changed Class system again, no closures, more simple and readable --> quicker
- Fixed -Nothing happening- bug on Safari with span-like Elements.
- Fixed critical error at loading in Evt implementation from Naja Framework.



Update Log v 0.9.5

- Works on all kind of objects
- All units available
- Lighter class system
- Color (hex, rgb & hsv)
- scrollLeft/scrollTop properties
- custom tween & easing interfaces available

